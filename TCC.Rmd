---
title: 'TCC'
author: "Gustavo Theil"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, error=TRUE) 

library(tidyverse)
library(ggsankey)
library(ggimage)
library(patchwork)

library(sf)
library(mapview)
library(units)

library(rdrobust)
library(rddensity)
library(fixest)

library(modelsummary)
library(gt)

mapviewOptions(basemaps = "CartoDB.Positron")
setwd("C:/git/TCC")
```

# Import dados

```{r "dados/eixos", cache = TRUE}
eixos <- read_sf("dados/PDE/sirgas_PDE_3-Eixos-EETU.shp") |>
  st_set_crs("epsg:31983") |> 
  select(geometry)

eixos.buffersimples <- eixos |> 
  st_buffer(1000) |> 
  st_union() |> 
  st_simplify(dTolerance = 100)

eixos.miolo <- eixos |> 
  st_buffer(50) |> 
  st_union() |> 
  st_buffer(-50) |> 
  nngeo::st_remove_holes() |> 
  st_as_sf()

eixos.contorno <- eixos |> 
  st_buffer(50) |> 
  st_union() |> 
  st_buffer(-50) |> 
  nngeo::st_remove_holes() |> 
  st_cast("MULTILINESTRING") |> 
  st_as_sf()

# Mapa eixo, geradores de eixo
list(
  eixos = bind_rows(eixos.miolo,
                    read_sf("dados/PDE/sirgas_PDE_3-Eixos-EETU.shp") |>
                      st_set_crs("epsg:31983") |> select(x = geometry), 
                    eixos.contorno),
  geradores_eixo = bind_rows(
    read_sf("dados/geradores-eixo/corredor-onibus/SIRGAS_SHP_corredoronibus_line.shp") |> 
      mutate(tipo = "onibus") |> select(tipo, geometry) |> st_set_crs("epsg:31983"),
    read_sf("dados/geradores-eixo/estacao-metro/SIRGAS_SHP_estacaometro_point.shp") |> 
      mutate(tipo = "metro") |> select(tipo, geometry) |> st_set_crs("epsg:31983"),
    read_sf("dados/geradores-eixo/estacao-trem/SIRGAS_SHP_estacaotrem.shp") |> 
      mutate(tipo = "trem") |> select(tipo, geometry) |> st_set_crs("epsg:31983")),
  macroareas = read_sf("dados/macroareas/SIRGAS_SHP_MACROAREAS.shp") |> 
    st_set_crs("epsg:31983")) |> 
  mapview(zcol = list(NULL, "tipo", "mc_sigla")) |> 
  mapshot(url = "tex/figuras/mapview/eixos.html")

gg <- ggplot() +
  geom_sf(aes(geometry = geometry, fill = mc_divisao),
          data = read_sf("dados/macroareas/SIRGAS_SHP_MACROAREAS.shp") |> 
            st_set_crs("epsg:31983"), colour = "darkgrey", lwd = .1) +
  scale_fill_grey("", start = .6, end = .95) +
  geom_sf(aes(fill = "Axis area"), data = eixos.miolo, fill = "darkblue", alpha = .1, colour = "black") +
  geom_sf(data = st_union(eixos), fill = "darkblue", alpha = .3, colour = NA) +
  theme_void() +
  theme(legend.position = "inside",
        legend.position.inside = c(.75, .4))

ggsave("tex/figuras/macroareas-eixos.pdf", gg, width = 10, height = 15)
```


```{r "dados/lotes", cache = TRUE}
IPTU <- read.csv("dados/IPTU/IPTU_2024.csv", sep=";", encoding = "latin1") |>  
    as_tibble() |>  
    select(sql = "NUMERO.DO.CONTRIBUINTE", 
           condominio = "NUMERO.DO.CONDOMINIO",
           area_terreno = "AREA.DO.TERRENO",
           area_construida = "AREA.CONSTRUIDA",
           area_ocupada = "AREA.OCUPADA",
           pavimentos = "QUANTIDADE.DE.PAVIMENTOS",
           ano_construcao = "ANO.DA.CONSTRUCAO.CORRIGIDO",
           tipo = "TIPO.DE.PADRAO.DA.CONSTRUCAO") |>  
    # Separação do número de contribuinte (SQL) em setor quadra e lote
    mutate(setor =  str_sub(sql, 1, 3),
           quadra = str_sub(sql, 4, 6),
           # Quando o lote é um condomínio, haverá vários SQLs no mesmo lote. CD = Condomínio
           lote = str_sub(sql, 7, 10) |>  
             ifelse(condominio == "00-0", yes = _, paste("CD", str_sub(condominio, 1, 2), sep = "")),
           # Tipo de uso
           uso = case_when(str_detect(tipo, "Residencial") ~ "residencial",
                         str_detect(tipo, "Comercial") ~ "comercial",
                         str_detect(tipo, "Oficina") ~ "industrial",
                         str_detect(tipo, "TERRENO") ~ "terreno",
                         str_detect(tipo, "Clube") ~ "entretenimento",
                         .default = "outros")) |> 
  # Agregar por SQL
  group_by(setor, quadra, lote) |>  
  summarize(unidades = n(),
            area_terreno = median(area_terreno), 
            area_construida = sum(area_construida), 
            area_ocupada = median(area_ocupada),
            pavimentos = median(pavimentos),
            ano_construcao = median(ano_construcao),
            uso_predominante = fct_infreq(uso) |> levels() |> first()) |>  
  ungroup() |>  
  mutate(densidade_construtiva = area_construida / area_terreno,
         densidade_habitacional = unidades / area_terreno,
         verticalizacao = area_construida / area_ocupada)

lotes <- list.files(path="dados/lotes/unzip", full.names = FALSE) |>  
  (\(.) paste("dados/lotes/unzip/", ., "/", ., ".shp", sep = ""))() |>  
  lapply(read_sf) |>  
  bind_rows() |>  
  st_set_crs("epsg:31983") |> 
  filter(st_centroid(geometry) |> st_covered_by(eixos.buffersimples) |> as.logical()) |> 
  mutate(lo_lote = ifelse(lo_lote == "0000", paste("CD", lo_condomi, sep = ""), lo_lote),
         lo_lote = ifelse(lo_tp_lote != "F", paste(lo_tp_lote, lo_lote, sep = ""), lo_lote)) |>  
  select(setor = lo_setor, quadra = lo_quadra, lote = lo_lote, tipo_lote = lo_tp_lote)

IPTU.lote <- lotes |>  
  left_join(IPTU, by = join_by(setor, quadra, lote)) |>  
  ungroup()

saveRDS(IPTU.lote, "rdata/IPTU-lote.rds")
saveRDS(lotes, "rdata/lotes.rds")
saveRDS(IPTU, "rdata/IPTU.rds")
IPTU <- readRDS("rdata/IPTU.rds")
gg <- IPTU |> 
  filter(uso_predominante == "residencial") |> 
  mutate(cota_parte = 1/densidade_habitacional) |> 
  filter(cota_parte < 600, densidade_construtiva < 5, pavimentos < 20) |> 
  select("Obs. Land Quota" = cota_parte, 
         "Obs. FAR" = densidade_construtiva, 
         "Storeys" = pavimentos) |> 
  pivot_longer(everything()) |> 
  ggplot() +
  geom_histogram(aes(x = value)) +
  facet_wrap(~ name, scales = "free") +
  scale_y_continuous(labels = scales::number) +
  labs(x = "", y = "Frequency") + 
  theme_classic()

ggsave("tex/figuras/indicadores.pdf", gg, width = 9, height = 3)

remove(IPTU, lotes)
```




```{r "dados/censo", cache = TRUE}
censo2010 <- read_sf("dados/censo/2010/35SEE250GC_SIR.shp") |> 
  filter(CD_GEOCODM == "3550308") |> 
  st_transform("epsg:31983") |> 
  select(id_setor = CD_GEOCODI) |> 
  left_join(readxl::read_excel("dados/censo/2010/Basico_SP1.XLS") |> 
              select(id_setor = Cod_setor, moradores = V002, domicilios = V001) |> 
              mutate(id_setor = as.character(id_setor)),
            by = join_by(id_setor)) |> 
  mutate(ano = 2010)

censo2022 <- read_sf("dados/censo/2022/SP_Malha_Preliminar_2022.shp") |> 
  filter(CD_MUN == "3550308") |> 
  st_transform("epsg:31983")  |>
  select(id_setor = CD_SETOR, moradores = v0001, domicilios = v0002) |> 
  mutate(ano = 2022)

censo <- bind_rows(list(censo2010, censo2022)) |> 
  filter(st_covered_by(st_centroid(geometry), eixos.buffersimples |> st_buffer(-200)) |> as.logical()) |>
  mutate(area = st_area(geometry)) 

saveRDS(censo, "rdata/censo.rds")
saveRDS(censo2010, "rdata/censo2010.rds")
saveRDS(censo2022, "rdata/censo2022.rds")

remove(censo2010, censo2022)
```


```{r}
censo |> 
  mutate(eixo = st_intersects(geometry, st_union(eixos.miolo)) |> as.logical() |> replace_na(FALSE)) |>
  # filter(st_distance(st_centroid(geometry), eixos.contorno) |> as.numeric() < 100) |> 
  # st_intersection(eixos) |>
  # mutate(area_eixo = st_area(geometry),
  #        percent_eixo = area_eixo / area) |>
  # mutate(moradores = (st_area(geometry) / area) * moradores) |> 
  st_drop_geometry() |>
  # group_by(ano) |>
  # summarize(moradores_eixo = sum(moradores * percent_eixo, na.rm = T),
  #           moradores = sum(moradores, na.rm = T))
  group_by(ano, eixo) |>
  summarize(moradores = sum(moradores, na.rm = T),
            domicilios = sum(domicilios, na.rm = T)) |>
  mutate(total_moradores = sum(moradores),
         total_domicilios = sum(domicilios))

```


# Tratamento dos dados

```{r "dados/areas-uso", cache = TRUE}
areas.uso <- censo |> 
  st_intersection(IPTU.lote) |> 
  mutate(periodo = case_when(ano_construcao > 2014 ~ "pos",
                             TRUE ~ "outros")) |> 
  group_by(id_setor, tipo_lote, uso_predominante, periodo) |> 
  summarize(area = st_union(geometry) |> st_area() |> as.numeric()) |> 
  st_drop_geometry() |> 
  bind_rows(censo |> 
              st_drop_geometry() |> 
              select(id_setor, area) |> 
              mutate(area = as.numeric(area)) |> 
              pivot_longer(area, names_to = "uso_predominante", values_to = "area") |> 
              mutate(uso_predominante = NA)) 

saveRDS(areas.uso, "rdata/areas-uso.rds")

areas.uso |> 
  mutate(posPDE = periodo == "pos") |> 
  group_by(tipo_lote, uso_predominante, posPDE) |> 
  summarize(area = sum(area)) |> 
  ungroup() |> 
  mutate(total = "Área do setor\n censitário",
         area = ifelse(is.na(tipo_lote) & is.na(uso_predominante), max(area) - (sum(area) - max(area)), area),
         percent = area / sum(area),
         tipo_lote = case_when(tipo_lote == "F" ~ "Fiscal",
                           tipo_lote == "M" ~ "Espaço Livre",
                           tipo_lote == "V" ~ "Vias de Acesso",
                           TRUE ~ "Não lote"),
         uso_predominante = case_when(uso_predominante == "" ~ "outros",
                           is.na(uso_predominante)~ "outros",
                           TRUE ~ uso_predominante) |> str_to_title(),
         posPDE = case_when(posPDE == TRUE ~ "Pós PDE",
                            posPDE == FALSE ~ "Pré PDE",
                            TRUE ~ NA)) |> 
  group_by(total) |> mutate(total = paste(total, "\n", round(sum(percent) * 100), "%", sep = "")) |> ungroup() |> 
  group_by(tipo_lote) |> mutate(tipo_lote = paste(tipo_lote, "\n", round(sum(percent) * 100, 2), "%", sep = "")) |> ungroup() |> 
  group_by(uso_predominante) |> mutate(uso_predominante = paste(uso_predominante, "\n", round(sum(percent) * 100, 2), "%", sep = "")) |> ungroup() |> 
  group_by(posPDE) |> mutate(posPDE = ifelse(is.na(posPDE), NA, paste(posPDE, "\n", round(sum(percent) * 100, 2), "%", sep = ""))) |> ungroup() |> 
  make_long(total, tipo_lote, uso_predominante, posPDE,value = area) |> 
  mutate(order = ifelse(str_detect(node, "outros|Não lote"), 1, 0)) |> 
  ggplot(aes(x = x, 
             next_x = next_x, 
             node = reorder(node, order), 
             next_node = reorder(next_node, order),
             fill = factor(node),
           value = value,
           label = node)) +
  geom_sankey(flow.alpha = 0.75, na.rm = T) +
  geom_sankey_label(size = 3.5, color = "black", fill = "white", alpha = .9) +
  theme_sankey() +
  scale_fill_viridis_d(option ="G") +
    scale_x_discrete(name = "", position = "top", labels = c("total" = "Setor censitário",
                                                           "tipo_lote" = "Tipo de lote",
                                                           "uso_predominante" = "Qualificação no IPTU",
                                                           "posPDE" = "Ano da construção")) +
  theme(legend.position = "none")

ggsave("tex/figuras/area_setor.pdf", width = 10, height = 5)

```


```{r "dados/censo-areas", cache = TRUE}
censo.areas <- areas.uso |> 
  ungroup() |> 
  mutate(uso_predominante = case_when(is.na(uso_predominante) & is.na(tipo_lote) & is.na(periodo) ~ "total",
                                      uso_predominante == "residencial" ~ "residencial",
                                      tipo_lote != "F" ~ "nao_lote",
                                      TRUE ~ "outros")) |> 
  group_by(id_setor, uso_predominante, periodo) |> 
  summarize(area = as.numeric(sum(area))) |>   
  pivot_wider(id_cols = c(id_setor), names_from = c(uso_predominante, periodo), values_from = area) |> 
  ungroup() |> 
  mutate(across(everything(), ~ replace_na(.x, 0))) |> 
  left_join(censo |> select(-area)) |> 
  mutate(area = total_NA,
         area_lote_absoluto = outros_pos + outros_outros + residencial_pos + residencial_outros,
         area_residencial = (residencial_outros + residencial_pos) / area_lote_absoluto,
         area_lote = area_lote_absoluto / area) |> 
  left_join(censo |> 
              st_set_geometry("geometry") |>
              st_intersection(eixos |> st_union()) |>
              mutate(area_eixo = as.numeric(st_area(geometry))) |>
              st_drop_geometry() |>
              select(id_setor, area_eixo_total = area_eixo)) |> 
   mutate(area_eixo = ifelse(is.na(area_eixo_total), 0, area_eixo_total / area),
          area_eixo_lote = replace_na(area_eixo_total, 0) / (area_lote_absoluto)) |> 
  select(id_setor, ano, moradores, domicilios, area, area_lote, area_residencial, area_eixo, area_eixo_lote, geometry)

  
  censo.areas 
  

saveRDS(censo.areas, "rdata/censo-areas.rds")
```


```{r "dados/distancias", cache = TRUE}
IPTU.distancias <- IPTU.lote |>
  mutate(
    centroid = st_centroid(geometry),
    posicao_centroid = case_when(
      !centroid |> st_intersects(eixos.miolo |> st_union()) |> as.logical() |> replace_na(0) ~ "fora",
      centroid |> st_intersects(eixos |> st_union()) |> as.logical() |> replace_na(0)        ~ "eixo",
      TRUE ~ "miolo_mas_fora"),
    distancia = as.numeric(st_distance(centroid, eixos.contorno)[,1])) |> 
    st_drop_geometry()

censo.distancias <- censo.areas |> 
  mutate(centroid = st_centroid(geometry),
         posicao_centroide = ifelse(centroid |> 
                                      st_intersects(eixos.miolo |> st_union()) |> 
                                      as.logical() |> 
                                      replace_na(0), 
                                    "eixo", "fora"),
         distancia = as.numeric(st_distance(centroid, eixos.contorno)[,1]))

saveRDS(censo.distancias, "rdata/censo-distancias.rds")
saveRDS(IPTU.distancias, "rdata/IPTU-distancias.rds")

censo.distancias |>
  pivot_longer(area_eixo:area_eixo_lote, values_to = "area_eixo", names_to = "nm") |> 
  st_drop_geometry() |>
  ggplot(aes(x = posicao_centroide, y = area_eixo, fill = nm)) +
  annotate("rect", xmin = 1.5, xmax = 2.5, ymin = .0, ymax = .05, fill = "darkred", alpha = .12) +
  annotate("rect", xmin = .5, xmax = 1.5, ymin = .9, ymax = 1, fill = "darkgreen", alpha = .12) +
  geom_hline(yintercept = .90, linetype = "dotted") +
  geom_hline(yintercept = .05, linetype = "dotted") +
  geom_violin(lwd = 0.25, stroke = 0) +
  facet_wrap(~ano) +
  theme_bw() +
  scale_y_continuous(labels = scales::percent, limits = c(0,1)) +
  scale_fill_manual("", values = c("darkgrey", "black"), labels = c("Percentual do eixo na área do setor", "Percentual do eixo na área de lote")) +
  labs(x = "Região mais próxima ao centroide", y = "Percentual da área em eixo") +
  theme(legend.position = "bottom")

ggsave("tex/figuras/percent-eixo.pdf", width = 7, height = 5)
```


<!-- ```{r} -->
<!-- IPTU.distancias <- readRDS("rdata/IPTU-distancias.rds") -->
<!-- censo.distancias <- readRDS("rdata/censo-distancias.rds") -->
<!-- areas.uso <- readRDS("rdata/areas-uso.rds") -->
<!-- IPTU.lote <- readRDS("rdata/IPTU-lote.rds") -->
<!-- censo <- readRDS("rdata/censo.rds") -->
<!-- df.censo <- readRDS("rdata/censo-final.rds") -->
<!-- df.IPTU <- readRDS("rdata/IPTU-final.rds") -->
<!-- ``` -->


```{r "dados/finais", cache = TRUE}
df.IPTU <- IPTU.distancias |> 
  mutate(posPDE = ano_construcao > 2014,
         residencial = uso_predominante == "residencial",
         grupo = case_when(posicao_centroid == "eixo" ~ "Treatment",
                           posicao_centroid == "fora" ~ "Control",
                           posicao_centroid == "miolo_mas_fora" ~ "Discarded",
                           TRUE ~ NA),
         distancia = case_when(posicao_centroid == "fora" ~ -distancia,
                               posicao_centroid == "eixo" ~ distancia,
                               posicao_centroid == "miolo_mas_fora" ~ distancia,
                               TRUE ~ NA)) |> 
  select(setor, quadra, lote, 
         distancia, grupo, unidades,
         pavimentos, densidade_construtiva, densidade_habitacional, 
         ano_construcao, posPDE, uso_predominante, posPDE) 


df.censo <- censo.distancias |>
  mutate(grupo = case_when(posicao_centroide == "eixo" & as.numeric(area_eixo_lote) > .9 ~ "Treatment",
                           posicao_centroide == "fora" & as.numeric(area_eixo_lote) < .05 ~ "Control",
                           TRUE ~ "Discarded"),
         distancia = case_when(posicao_centroide == "fora" ~ -distancia,
                               posicao_centroide == "eixo" ~ distancia,
                               TRUE ~ NA)) |> 
  mutate(densidade = moradores / area,
         densidade_lote = moradores / (area * area_lote),
         densidade_residencial = moradores / (area * area_lote * area_residencial)) |> 
  select(id_setor, ano, distancia, grupo, area, moradores, domicilios, starts_with("densidade"), 
         area_residencial)

saveRDS(df.censo, "rdata/censo-final.rds")
saveRDS(df.IPTU, "rdata/IPTU-final.rds")
```


```{r "dados/mapa-tratamento", cache = TRUE}
distrito <- read_sf("dados/distrito/SIRGAS_SHP_distrito.shp") |> 
  filter(ds_nome == "VILA MARIANA") |> 
  select()

metro <- read_sf("dados/geradores-eixo/estacao-metro/SIRGAS_SHP_estacaometro_point.shp") |> 
  st_set_crs("epsg:31983") |> 
  st_crop(distrito) |> 
  (\(pontos) bind_cols(pontos, st_coordinates(pontos)))() |> 
  st_drop_geometry() |> 
  group_by(emt_nome) |> 
  summarize(x = mean(X), y = mean(Y))

gg.dados <- df.IPTU |> 
  right_join(IPTU.lote |> select(setor, quadra, lote) |> st_crop(distrito)) |> 
  mutate(cor = case_when(grupo == "tratamento" & uso_predominante == "residencial" & posPDE == TRUE  ~ "Treatment residential new",
                         grupo == "tratamento" & uso_predominante == "residencial" & posPDE == FALSE ~ "Treatment residential old",
                         grupo == "tratamento" & uso_predominante != "residencial"                   ~ "Treatment not residential",
                         grupo == "controle" & uso_predominante == "residencial" & posPDE == TRUE    ~ "Control residential new",
                         grupo == "controle" & uso_predominante == "residencial" & posPDE == FALSE   ~ "Control residential old",
                         grupo == "controle" & uso_predominante != "residencial"                     ~ "Control not residential",
                         TRUE ~ "Other"))
gg <- ggplot() +
  geom_sf(data = gg.dados,
          aes(geometry = geometry, fill = cor),
          lwd = .1, stroke = 0, colour = NA) + 
  theme_void() +
   scale_fill_manual(values = c("Other" = "#E0E2E6",
                               "Treatment residential new"  = "#1BB6AFFF",
                               "Treatment residential old"= "#0076BBFF",
                               "Treatment not residential"   = "#172869FF",
                               "Control residential new"    = "#FF3200FF",
                               "Control residential old"  = "#E9A17CFF",
                               "Control not residential"     = "#E9E4A6FF"),
                     name = "Lot group") +
  theme(legend.position = "inside",
        legend.position.inside = c(.85, .8))


ggsave("tex/figuras/mapa-lotes.pdf", gg, height = 8, width = 10)
ggsave("tex/figuras/mapa-lotes-metro.pdf", height = 8, width = 10,
       plot = gg +   
         geom_point(data = metro, aes(x = x, y = y), 
                    size = 8, shape = 15, colour = "white", fill = "white") +
         geom_image(data = metro, aes(x = x, y = y, image = "tex/figuras/icone_metro.png"), size = .025) +
         geom_label(data = metro, aes(x = x, y = y, label = emt_nome), nudge_y = 80, size = 1.5))

gg <- ggplot() +
  geom_sf(data = df.censo |>
            filter(ano == 2022) |>
            right_join(censo |> filter(ano == 2022) |> select(id_setor) |> st_crop(distrito)),
          aes(geometry = geometry, fill = grupo),
          colour = "#313638") +
  geom_sf(data = st_make_grid(eixos |> st_union() |> st_crop(distrito), 
                              what = "corners", 
                              square = T,
                              cellsize = 10) |> as_tibble() |> 
            filter(st_intersects(geometry, eixos |> st_crop(distrito) |> st_union()) |> as.logical()),
          aes(geometry = geometry), size = .25, stroke = 0, colour = "black") +
  scale_fill_manual(values = c("controle" = "#89973DFF",
                               "tratamento" = "#E8B92FFF",
                               "descartado" = "#A45E41FF"),
                    labels = c("controle" = "Controle",
                               "tratamento" = "Tratamento",
                               "descartado" = "Removido da\n análise")) +
  theme_void() +
  theme(legend.position = "inside",
      legend.position.inside = c(.85, .8))

ggsave("tex/figuras/mapa-censo.pdf", height = 10, width = 10)

remove(distrito, metro, gg.dados, gg)
```

# Análise

```{r "analise/did-censo"}
data <- df.censo |>
  ungroup() |> 
  drop_na() |> 
  filter(grupo != "descartado")

modelsummary(list(
  "(A)" = lm(densidade ~ factor(grupo) * factor(ano), data = data |> filter(abs(distancia) <= 50)),
  "(B)" = feols(densidade ~ factor(grupo) * factor(ano) | id_setor + ano, 
                data = data |> 
                  mutate(id_setor = str_sub(id_setor, 1, 15)) |> 
                  group_by(id_setor) |> 
                  filter(abs(distancia) <= 50, n() == 2, abs(area / sum(area) - .5) < .001, abs(distancia / sum(distancia) - .5) < .001)),
  "(C)" = lm(densidade ~ factor(grupo) * factor(ano), data = data |> filter(abs(distancia) <= 100)),
  "(D)" = feols(densidade ~ factor(grupo) * factor(ano) | id_setor + ano, 
                data = data |> 
                  mutate(id_setor = str_sub(id_setor, 1, 15)) |> 
                  group_by(id_setor) |> 
                  filter(abs(distancia) <= 100, n() == 2, abs(area / sum(area) - .5) < .001, abs(distancia / sum(distancia) - .5) < .001))),
  stars = TRUE, statistic = NULL,
  coef_map = c("(Intercept)" = "Intercepto",
               "factor(grupo)tratamento" = "T (Grupo de tratamento)",
               "factor(ano)2022" = "P (Período pós PDE)",
               "factor(grupo)tratamento:factor(ano)2022" = "T x P"),
  gof_omit = "AIC|BIC|Log.Lik.|RMSE|R2 Within|R2 Within Adj.|Std.Errors|FE: id_setor|FE: ano",
  output = "gt") |> 
  tab_caption("Resultado diff-in-diff para a densidade populacional") |> 
  tab_spanner("50m", 2:3) |> 
  tab_spanner("100m", 4:5) |> 
  gtsave("tex/tabelas/did-censo.tex")

```

```{r "analise/delta-censo"}
df.censo |> 
  filter(abs(distancia) <= 50) |> 
  group_by(grupo, ano = paste("a", ano, sep = "")) |> 
  summarize(moradores = sum(moradores, na.rm = TRUE)) |> 
  pivot_wider(id_cols = grupo, names_from = ano, values_from = moradores) |> 
  mutate(delta = a2022 - a2010)
```


```{r "analise/did-censo-robustez"}
(df.censo |> 
  filter(grupo != "Discarded") |> 
  mutate(id_setor = str_sub(id_setor, 1, 15)) |> 
  group_by(id_setor) |> 
  filter(grupo != "Discarded", n() == 2, abs(area / sum(area) - .5) < .001, abs(distancia / sum(distancia) - .5) < .001) |> 
  (\(df, start_roll = 150, end_roll = 50, step = 5) {
    seq(start_roll, end_roll, by = -step) |>
      purrr::map_dfr(\(banda) {
        df |>
          filter(abs(distancia) <= banda) |>
          feols(densidade ~ factor(grupo) * factor(ano)|id_setor, data = _) |>
          broom::tidy(conf.int = TRUE, conf.level = .9) |>
          mutate(banda = banda)
      })
  })(df = _) |> 
  drop_na() |> 
  ggplot(aes(x = banda, y = estimate, colour = term, fill = term)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .25) +
  geom_line(lwd = 1) +
  # scale_colour_viridis_d() +
  theme_classic() + 
  labs(x = "Distance Bandwidth", y = "Estimate", colour = "Parameter", fill = "Parameter")) |> 
  ggsave("tex/figuras/did-censo-bandas.pdf", plot = _, width = 8, height = 4)

```


```{r "analise/did-IPTU"}
data <- df.IPTU |> 
  filter(abs(distancia) <= 50, grupo != "descartado") |> 
  mutate(residencial = uso_predominante == "residencial")

modelsummary(list(
  "densidade_construtiva" = lm(densidade_construtiva ~ factor(grupo) * factor(posPDE), 
                               data = data |> filter(uso_predominante == "residencial")),
  "densidade_habitacional" = lm(densidade_habitacional ~ factor(grupo) * factor(posPDE), 
                                data = data |> filter(uso_predominante == "residencial")),
  "pavimentos" = lm(pavimentos ~ factor(grupo) * factor(posPDE), 
                    data = data |> filter(uso_predominante == "residencial"))), 
  stars = TRUE, statistic = NULL, gof_omit = c("AIC|BIC|Log.Lik.|RMSE"),
  coef_rename = coef_rename(c("Intercepto", "Tratamento", "Pós PDE", "Tratamento x Pós PDE")), 
  output = "gt") |> 
  tab_caption("Resultados do DiD para unidades dentro de 50m da fronteira de eixo") |> 
  gtsave("tex/tabelas/did-IPTU.tex")

# RDD (p = 0) é igual ao DiD 
data |> 
  filter(grupo != "descartado", uso_predominante == "residencial", posPDE) |>     
  (\(df) rdrobust(as.numeric(df$densidade_construtiva), df$distancia, 
                  kernel = "uniform", p = 0, h = 50))(df = _) |> 
  summary()

data |> 
  filter(grupo != "descartado", uso_predominante == "residencial", posPDE, abs(distancia) < 50) |>     
  lm(densidade_construtiva ~ factor(grupo), data = _) |> 
  summary()

```

```{r "analise/did-IPTU-bandas"}
gg <- df.IPTU |> 
  filter(grupo != "Discarded") |> 
  (\(df, start_roll = 150, end_roll = 10, step = 5) {
    seq(start_roll, end_roll, by = -step) |>
      purrr::map_dfr(\(banda) {
        df |>
          filter(abs(distancia) <= banda) |>
          lm(densidade_construtiva ~ factor(grupo) * factor(posPDE), data = _) |>
          broom::tidy(conf.int = TRUE, conf.level = .99) |>
          mutate(banda = banda)
      })
  })(df = _) |> 
  mutate(term = case_when(term == "factor(grupo)Treatment" ~ "Treatment",
                          term == "factor(grupo)Treatment:factor(posPDE)TRUE" ~ "Treatment x Post SMP",
                          term == "factor(posPDE)TRUE" ~ "Post SMP",
                          TRUE ~ NA)) |> 
  drop_na() |> 
  ggplot(aes(x = banda, y = estimate, colour = term, fill = term)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .5) +
  geom_line(lwd = 1) +
  # scale_colour_viridis_d() +
  theme_classic() +
  labs(x = "Distance Bandwidth", y = "Estimate", colour = "Parameter", fill = "Parameter")

gg
ggsave("tex/figuras/did-IPTU-bandas.pdf", gg, width = 8, height = 4)


```


```{r "analise/eventStudy-IPTU"}
data <- df.IPTU |> 
  ungroup() |> 
  mutate(ano_construcao = as.integer(ano_construcao),
         residencial = as.numeric(uso_predominante == "residencial")) |> 
  filter(abs(distancia) <= 50, grupo != "Discarded", ano_construcao >= 2002, ano_construcao <= 2022)

extrair.coefs <- function(regressao){
  summ <- summary(regressao)
  cbind(summ$coefficients |> names(),
        unname(summ$coefficients),
        unname(summ$se)) |> as.data.frame() |> 
    rename("nome" = 1, "coef" = 2, "se" = 3)
}

bind_rows(
  # Três instrumentos p/ lotes residenciais
  feols(densidade_construtiva ~ i(factor(ano_construcao), factor(grupo), ref = 2014), 
        data = data |> filter(uso_predominante == "residencial")) |> 
    extrair.coefs() |> mutate(variavel = "Building Density", residencial = T),
  feols(densidade_habitacional ~ i(factor(ano_construcao), factor(grupo), ref = 2014), 
        data = data |> filter(uso_predominante == "residencial")) |> 
    extrair.coefs() |> mutate(variavel = "Dwelling Unit Density", residencial = T),
  feols(pavimentos ~ i(factor(ano_construcao), factor(grupo), ref = 2014), 
        data = data |> filter(uso_predominante == "residencial")) |> 
    extrair.coefs() |> mutate(variavel = "Storeys", residencial = T),
  
  # Três instrumentos p/ lotes NÃO residenciais
  feols(densidade_construtiva ~ i(factor(ano_construcao), factor(grupo), ref = 2014), 
        data = data |> filter(uso_predominante != "residencial")) |> 
    extrair.coefs() |> mutate(variavel = "Building Density", residencial = F),
  feols(densidade_habitacional ~ i(factor(ano_construcao), factor(grupo), ref = 2014), 
        data = data |> filter(uso_predominante != "residencial")) |> 
    extrair.coefs() |> mutate(variavel = "Dwelling Unit Density", residencial = F),
  feols(pavimentos ~ i(factor(ano_construcao), factor(grupo), ref = 2014), 
        data = data |> filter(uso_predominante != "residencial")) |> 
    extrair.coefs() |> mutate(variavel = "Storeys", residencial = F)) |> 
  
  filter(endsWith(nome, "Treatment")) |>
  mutate(ano = str_sub(nome, 27,28), 
         coef = as.numeric(coef),
         se = as.numeric(se)) |> 
  bind_rows(data.frame(ano = "14", coef = 0, se = 0, residencial = 1:6<=3, 
                       variavel = c("Dwelling Unit Density", "Storeys", "Building Density"))) |> 
  ggplot(aes(x = as.numeric(ano) + 2000, y = coef, colour = residencial)) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 2014, linetype = "dotted") +
  geom_point() +
  geom_line(alpha = .5) +
  geom_errorbar(aes(ymin = coef - 1.96 * se, ymax = coef + 1.96 * se), width = .2) +
  facet_grid(rows = "variavel", scales = "free_y") +
  scale_colour_manual(name = "",
                      values = c("TRUE" = "black", "FALSE" = "darkgrey"),
                      labels = c("TRUE" = "Residential on axis\n versus residencial outside", 
                                 "FALSE" = "Non residential on axis\n versus non residencial outside")) +
  scale_x_continuous(breaks = 2002 + 0:5*4) +
  labs(x = "", y = "DiD coeficient (95% confidence intervals)") +
  theme_bw() +
  theme(legend.position = "bottom")

ggsave("tex/figuras/event-study.pdf", width = 7, height = 5.5)
```

```{r "analise/delta-IPTU"}
df.IPTU |> 
  drop_na() |> 
  filter(abs(distancia) <= 50, ano_construcao > 2002, ano_construcao <= 2022, grupo != "Discarded") |> 
  mutate(ano_construcao = as.integer(ano_construcao)) |> 
  group_by(grupo, ano_construcao) |> 
  summarize(lotes = n()) |> 
  group_by(ano_construcao) |>
  mutate(lotes = ifelse(grupo == "Control", -lotes, lotes),
         soma = sum(lotes),
         grupo = factor(grupo, levels = c("Treatment", "Control"))) |> 
  ggplot(aes(x = ano_construcao)) +
  geom_col(aes(y = lotes, fill = grupo)) +
  geom_line(aes(y = soma, colour = "diff")) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 2014.5, linetype = "dotted") +
  scale_colour_manual("", values = c("diff" = "black"), labels = c("diff" = "Difference between the groups")) +
  scale_fill_manual("Group", values = c("Treatment" = "#E8B92FFF", "Control" = "#89973DFF")) +
  labs(x = "Year of construction", y = "Number of lots built") +
  theme_minimal()

ggsave("tex/figuras/IPTU-delta-lotes.pdf", width = 8, height = 3.5)

df.IPTU |> 
  drop_na() |> 
  filter(abs(distancia + 5) <= 50, ano_construcao > 2002, ano_construcao <= 2022, grupo != "Discarded") |> 
  mutate(ano_construcao = as.integer(ano_construcao)) |> 
  group_by(grupo, ano_construcao) |> 
  summarize(unidades = sum(unidades)) |> 
  group_by(ano_construcao) |>
  mutate(unidades = ifelse(grupo == "Control", -unidades, unidades),
         soma = sum(unidades),
         grupo = factor(grupo, levels = c("Treatment", "Control"))) |> 
  ggplot(aes(x = ano_construcao)) +
  geom_col(aes(y = unidades, fill = grupo)) +
  geom_line(aes(y = soma, colour = "diff")) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_colour_manual("", values = c("diff" = "black"), labels = c("diff" = "Difference between the groups")) +
  scale_fill_manual("Group", values = c("Treatment" = "#E8B92FFF", "Control" = "#89973DFF")) +
  labs(x = "Year of construction", y = "Number of dwelling units built") +
  theme_minimal()
ggsave("tex/figuras/IPTU-delta-unidades.pdf", width = 8, height = 3.5)

```


```{r}
tidy.rdrobust <- function(object, ...){
    ret <- data.frame(term = row.names(object$coef), 
                      estimate = object$coef[, 1], 
                      std.error = object$se[, 1], 
                      statistic = object$z[, 1],
                      p.value = object$pv[, 1], 
                      conf.low = object$ci[,1],
                      conf.high = object$ci[, 2])
    row.names(ret) <- NULL
    ret
}

glance.rdrobust <- function(object, ...){
    ret <- data.frame("Observações à esquerda"  = object$N_h[1],
                      "Observações à direita" = object$N_h[2],
                      "Largura de Banda" = round(object$bws[1], 1))
        ret
}

```


```{r "analise/rdd-plot-censo"}
df.censo |> 
  drop_na() |> 
  ggplot(aes(x = distancia, fill = factor(grupo, levels = c("Discarded", "Control", "Treatment")))) +
  geom_histogram(breaks = (0:30-15)*20, colour = "#313638") +
  geom_vline(xintercept = 0, linetype = "dotted") +
  labs(x = "Distance to axis border", y = "Frequency", fill = "Group") +
  scale_fill_manual(values = c("Control" = "#89973DFF",
                               "Treatment" = "#E8B92FFF",
                               "Discarded" = "#A45E41FF")) +
  scale_x_continuous(breaks = (0:8 - 4) * 60, labels = function(x) abs(x)) +
  theme_classic()

ggsave("tex/figuras/rdd-balanceamento-censo.pdf", width = 7, height = 4)

df.censo |>
  filter(ano == 2022, grupo != "Discarded", abs(distancia) <= 300) |>
  (\(df) rdplot(as.numeric(df$densidade), df$distancia,
                binselect = "es", p = 1))(df = _)


df.censo |>
  filter(ano == 2010, grupo != "Discarded", abs(distancia) <= 300) |>
  (\(df) rdplot(as.numeric(df$densidade), df$distancia,
              binselect = "es", p = 1))(df = _)
```


```{r "analise/rdd-reg-censo"}
df.censo |> 
  filter(ano == 2022, grupo != "Discarded") |>     
  (\(df) rdrobust(as.numeric(df$densidade), df$distancia, 
                  kernel = "tri", p = 1))(df = _) |> 
  summary()

df.censo |> 
  filter(ano == 2010, grupo != "Discarded") |>     
  (\(df) rdrobust(as.numeric(df$densidade), df$distancia, 
                  kernel = "tri", p = 1))(df = _) |> 
  summary()
```


```{r "analise/rdd-plot-IPTU"}

df.IPTU |> 
  filter(uso_predominante == "residencial") |> 
  ggplot(aes(x = distancia, fill = grupo)) +
  geom_histogram(breaks = (0:40-20)*20, colour = "#313638") +
  geom_vline(xintercept = 0, linetype = "dotted") +
  labs(x = "Distância à fronteira do eixo", y = "Frequência", fill = "Grupo") +
  scale_fill_manual(values = c("Control" = "#89973DFF",
                               "Treatment" = "#E8B92FFF",
                               "Discarded" = "#A45E41FF")) +
  theme_classic()

ggsave("tex/figuras/rdd-balanceamento-IPTU.pdf", width = 6, height = 4)


(df.IPTU |>
  filter(grupo != "Discarded", abs(distancia) <= 300, uso_predominante == "residencial") |>
  (\(df) rdplot(as.numeric(df$densidade_construtiva), df$distancia,
                binselect = "qs", p = 1, col.dots = "black", col.lines = "black")$rdplot + 
     labs(title = "",  x = "Distância",y = "Building Density") +
     theme_minimal())(df = _) +

df.IPTU |>
  filter(grupo != "Discarded", abs(distancia) <= 300, uso_predominante == "residencial") |>
  (\(df) rdplot(as.numeric(df$densidade_habitacional), df$distancia,
                binselect = "qs", p = 1, col.dots = "black", col.lines = "black")$rdplot + 
     labs(title = "",  x = "Distância",y = "Dwelling Unit Density") +
     theme_minimal())(df = _) +

df.IPTU |>
  filter(grupo != "Discarded", abs(distancia) <= 300, uso_predominante == "residencial") |>
  (\(df) rdplot(as.numeric(df$pavimentos), df$distancia,
                binselect = "qs", p = 1, col.dots = "black", col.lines = "black")$rdplot + 
     labs(title = "",  x = "Distância",y = "Storeys") +
     theme_minimal())(df = _)) |> 
  ggsave("tex/figuras/rdd-plot-IPTU.pdf", plot = _, width = 11, height = 3)


```

```{r "analise/rdd-reg-IPTU"}
list(
  "Densidade Construtiva" = df.IPTU |> 
    filter(grupo != "Discarded", uso_predominante == "residencial") |>     
    (\(df) rdrobust(as.numeric(df$densidade_construtiva), df$distancia, 
                    kernel = "tri", p = 1))(df = _),
  "Densidade Habitacional" = df.IPTU |> 
    filter(grupo != "Discarded", uso_predominante == "residencial") |>     
    (\(df) rdrobust(as.numeric(df$densidade_habitacional), df$distancia, 
                    kernel = "tri", p = 1))(df = _),
  "Pavimentos" = df.IPTU |> 
    filter(grupo != "Discarded", uso_predominante == "residencial") |>     
    (\(df) rdrobust(as.numeric(df$pavimentos), df$distancia, 
                    kernel = "tri", p = 1))(df = _)) |> 
  modelsummary(stars = TRUE, statistic = NULL)


```

```{r "analise/rdd-plot-IPTU-posPDE"}

df.IPTU |> 
  filter(uso_predominante == "residencial", posPDE) |> 
  ggplot(aes(x = distancia, fill = grupo)) +
  geom_histogram(breaks = (0:40-20)*20, colour = "#313638") +
  geom_vline(xintercept = 0, linetype = "dotted") +
  labs(x = "Distância à fronteira do eixo", y = "Frequência", fill = "Grupo") +
  scale_fill_manual(values = c("Control" = "#89973DFF",
                               "Treatment" = "#E8B92FFF",
                               "Discarded" = "#A45E41FF")) +
  theme_classic()



(df.IPTU |>
  filter(grupo != "Discarded", abs(distancia) <= 300, uso_predominante == "residencial", posPDE) |>
  (\(df) rdplot(as.numeric(df$densidade_construtiva), df$distancia,
                binselect = "qs", p = 1, col.dots = "black", col.lines = "black")$rdplot + 
     labs(title = "",  x = "Distância",y = "Building Density") +
     theme_minimal())(df = _) +

df.IPTU |>
  filter(grupo != "Discarded", abs(distancia) <= 300, uso_predominante == "residencial", posPDE) |>
  (\(df) rdplot(as.numeric(df$densidade_habitacional), df$distancia,
                binselect = "qs", p = 1, col.dots = "black", col.lines = "black")$rdplot + 
     labs(title = "",  x = "Distância",y = "Dwelling Unit Density") +
     theme_minimal())(df = _) +

df.IPTU |>
  filter(grupo != "Discarded", abs(distancia) <= 300, uso_predominante == "residencial", posPDE) |>
  (\(df) rdplot(as.numeric(df$pavimentos), df$distancia,
                binselect = "qs", p = 1, col.dots = "black", col.lines = "black")$rdplot + 
     labs(title = "",  x = "Distância",y = "Storeys") +
     theme_minimal())(df = _)) |> 
  ggsave("tex/figuras/rdd-plot-IPTU-posPDE.pdf", plot = _, width = 11, height = 3)


```


```{r "analise/rdd-reg-IPTU-posPDE"}
list(
  "Densidade Construtiva" = df.IPTU |> 
    filter(grupo != "Discarded", uso_predominante == "residencial", posPDE) |>     
    (\(df) rdrobust(as.numeric(df$densidade_construtiva), df$distancia, 
                    kernel = "tri", p = 1))(df = _),
  "Densidade Habitacional" = df.IPTU |> 
    filter(grupo != "Discarded", uso_predominante == "residencial", posPDE) |>     
    (\(df) rdrobust(as.numeric(df$densidade_habitacional), df$distancia, 
                    kernel = "tri", p = 1))(df = _),
  "Pavimentos" = df.IPTU |> 
    filter(grupo != "Discarded", uso_predominante == "residencial", posPDE) |>     
    (\(df) rdrobust(as.numeric(df$pavimentos), df$distancia, 
                    kernel = "tri", p = 1))(df = _)) |> 
  modelsummary(stars = TRUE, statistic = NULL, output = "gt") |> 
  tab_caption("Resultados do RDD apenas com lotes edificados pós PDE") |> 
  gtsave("tex/tabelas/rdd-IPTU.tex")

list(
  "Densidade Construtiva" = df.IPTU |> 
    filter(grupo != "Discarded", uso_predominante == "residencial", posPDE) |>     
    (\(df) rdrobust(as.numeric(df$densidade_construtiva), df$distancia, 
                    kernel = "tri", p = 1, c = -100))(df = _),
  "Densidade Habitacional" = df.IPTU |> 
    filter(grupo != "Discarded", uso_predominante == "residencial", posPDE) |>     
    (\(df) rdrobust(as.numeric(df$densidade_habitacional), df$distancia, 
                    kernel = "tri", p = 1, c = -100))(df = _),
  "Pavimentos" = df.IPTU |> 
    filter(grupo != "Discarded", uso_predominante == "residencial", posPDE) |>     
    (\(df) rdrobust(as.numeric(df$pavimentos), df$distancia, 
                    kernel = "tri", p = 1, c = -100))(df = _))  |> 
  modelsummary(stars = TRUE, statistic = NULL, output = "gt") |> 
  tab_caption("Teste placebo do RDD com o cutoff deslocado 100 metros para fora do eixo") |> 
  gtsave("tex/tabelas/rdd-IPTU-placebo.tex")


```

# IC




```{r "dados/raster-create", cache = T}
# geoms.IPTU <- IPTU.lote %>% 
#   filter(! st_is_empty(geometry)) %>% 
#   st_as_sf() %>% 
#   mutate(area = st_area(geometry) %>% as.numeric()) %>% 
#   select(id = setor, area, unidades, area_construida, area_ocupada, area_terreno)
# 
# geoms.censo <- censo %>% 
#   mutate(area = st_area(geometry) %>% as.numeric()) %>% 
#   select(id = id_setor_censitario, area, populacao = v0001, domicilios = v0002, domicilios_ocupados = v0007)
# 
# bbox <- st_bbox(geoms.censo)
# 
# raster <- raster::raster(xmn = bbox["xmin"], xmx = bbox["xmax"], ymn = bbox["ymin"], ymx = bbox["ymax"],
#             res = 800, crs = st_crs(geoms.censo)$proj4string, vals = NA)
```


```{r "dados/raster-extract", cache = T}
# result.IPTU <- exact_extract(raster, geoms.IPTU, include_xy = T, 
#                              include_cols = c("id", "area", "unidades", "area_construida", "area_ocupada",
#                                               "area_terreno"), 
#                              force_df = T, coverage_area = T, progress = F) %>% 
#   bind_rows %>% 
#   mutate(percent_intersect = coverage_area / area,
#          across(unidades:area_terreno, ~ .x * percent_intersect)) %>% 
#   group_by(x, y) %>% 
#   summarize(unidades = sum(unidades),
#             area_ocupada = sum(area_ocupada),
#             area_construida = sum(area_construida),
#             area_terreno = sum(area_terreno)) %>% 
#   ungroup() %>% 
#   mutate(cota_parte = area_terreno / unidades,
#          cota_parte_inversa = unidades / area_terreno,
#          CA = area_construida / area_terreno,
#          verticalizacao = area_construida / area_ocupada)
# 
# result.censo <- exact_extract(raster, geoms.censo, include_xy = T, 
#                         include_cols = c("id", "area", "populacao", "domicilios", "domicilios_ocupados"), 
#                         force_df = T, coverage_area = T, progress = F) %>% 
#   bind_rows %>% 
#   mutate(percent_intersect = coverage_area / area,
#          across(c(area, populacao, domicilios, domicilios_ocupados), ~ .x * percent_intersect)) %>% 
#   group_by(x, y) %>% 
#   summarize(populacao = sum(populacao),
#             area = sum(area),
#             domicilios = sum(domicilios),
#             domicilios_ocupados = sum(domicilios_ocupados))
# 
# result <- full_join(result.IPTU, result.censo) %>% 
#   mutate(espectro_irregularidade = unidades / (unidades + domicilios),
#          densidade_residencial = populacao / area_terreno,
#          densidade_total = populacao / area)
# 
# result %>% 
#   modelsummary::datasummary_skim()
```

```{r}
load("C:/git/ic-densidade/IC_cache/html/data_raster_extract_2c2a96c2ad2ce92bcc603c3dc947fd95.RData")
result |> filter(populacao > 0) |> summarize(media = mean(populacao), mediana = median(populacao), sd = sd(populacao))

(result |> 
  filter(populacao > 0) |> 
  ggplot(aes(x = populacao)) + 
  geom_histogram() +
  theme_classic() +
  labs(x = "População da célula do raster", y = "Frequência")) |> 
  ggsave("tex/figuras/populacao-distribuicao-raster.pdf", plot = _, width = 7, height = 4)
```


```{r}
result |>
  filter(populacao > 0) |> 
  mutate(densidade_total = densidade_total * 10^6,
         densidade_residencial = densidade_residencial * 10^6,
         cota_parte_inversa = cota_parte_inversa * 10 ^ 6) |> 
  select(densidade_construtiva = CA, 
         densidade_habitacional = cota_parte_inversa, 
         verticalizacao,
         densidade_populacional = densidade_total,
         espectro_irregularidade,
         everything()) |> 
  (\(df) {
    list("(A) Nível" = df |> 
           filter(abs(espectro_irregularidade - .5) <= .05) |>
           lm(populacao ~ unidades + area_construida + verticalizacao, data = _) |> 
           summary(),
         "(B) Log" = df |> 
           filter(abs(espectro_irregularidade - .5) <= .05) |>
           lm(log(populacao) ~unidades + area_construida + verticalizacao, data = _) |> 
           summary(),
         "(C) Nível" = df |> 
           filter(abs(espectro_irregularidade - .5) <= .05) |>
           lm(densidade_populacional ~ densidade_construtiva + densidade_habitacional + verticalizacao, data = _) |> 
           summary(),
         "(D) Log" = df |> 
           filter(abs(espectro_irregularidade - .5) <= .05) |>
           lm(log(densidade_populacional) ~ densidade_construtiva + densidade_habitacional + verticalizacao, data = _) |> 
           summary())
  })(df = _) |> 
  modelsummary(statistic = NULL, stars = TRUE, fmt = 3, output = "gt", gof_omit = "RMSE",
               coef_rename = coef_rename(c("Intercepto", "Unidades", "Área construída (m2)", "Verticalização", 
                                           "Densidade construtiva", "Densidade habitacional"),
                                         titlecase = FALSE)) |> 
  tab_spanner("y = População", columns = 2:3) |> 
  tab_spanner("y = Densidade", columns = 4:5) |> 
  tab_caption("Resultados da regressão, para espectro de irregularidade entre 45 e 55%") |> 
  gtsave("tex/tabelas/regressao-1.tex")

```


```{r}
(result |> 
  filter(populacao > 0) |>
  mutate(densidade_total = densidade_total * 10^6) |> 
  # select(densidade_construtiva = CA, 
  #        densidade_habitacional = cota_parte_inversa, 
  #        verticalizacao,
  #        densidade_populacional = densidade_total,
  #        espectro_irregularidade) |> 
  (\(df, start_roll = .2, end_roll = .01, step = .01) {
    seq(start_roll, end_roll, by = -step) |>
      purrr::map_dfr(\(banda) {
        bind_rows(
          df |>
            filter(abs(espectro_irregularidade - .5) <= banda) |>
            lm(populacao ~ unidades + area_construida + verticalizacao, data = _) |>
            broom::tidy(conf.int = TRUE, conf.level = .95) |>
            mutate(banda = banda, forma = "linear"),
          df |>
            filter(abs(espectro_irregularidade - .5) <= banda) |>
            lm(log(populacao) ~ unidades + area_construida + verticalizacao, data = _) |>
            broom::tidy(conf.int = TRUE, conf.level = .99) |>
            mutate(banda = banda, forma = "log")
        )
        
      })
  })(df = _) |> 
  drop_na() |> 
  # filter(term != "(Intercept)") |> 
  ggplot(aes(x = banda, y = estimate, colour = term, fill = term)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .5) +
  geom_line(lwd = 1) +
  ggh4x::facet_grid2(cols = vars(forma), rows = vars(term), scale = "free", independent = "y") +
  scale_colour_viridis_d() +
  scale_fill_viridis_d() +
  theme_classic() +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::number) +
  labs(x = "Bandwidth do recorte do espectro de irregularidade", y = "Estimativa do parâmetro", colour = "Parâmetro", fill = "Parâmetro")) |> 
  (\(plot) ggsave("tex/figuras/robustez-regressao1pop.pdf", plot = plot, width = 10, height = 7))()


```

```{r}
result |> 
  filter(populacao > 0) |>
  mutate(densidade_total = densidade_total * 10^6) |> 
  select(densidade_construtiva = CA,
         densidade_habitacional = cota_parte_inversa,
         verticalizacao,
         densidade_populacional = densidade_total,
         espectro_irregularidade,
         everything()) |>
  (\(df, start_roll = .2, end_roll = .01, step = .01) {
    seq(start_roll, end_roll, by = -step) |>
      purrr::map_dfr(\(banda) {
        bind_rows(
          df |>
            filter(abs(espectro_irregularidade - .5) <= banda) |>
            lm(densidade_populacional ~ densidade_construtiva + densidade_habitacional + verticalizacao, data = _) |>
            broom::tidy(conf.int = TRUE, conf.level = .95) |>
            mutate(banda = banda, forma = "linear"),
          df |>
            filter(abs(espectro_irregularidade - .5) <= banda) |>
            lm(log(densidade_populacional) ~ densidade_construtiva + densidade_habitacional + verticalizacao, data = _) |>
            broom::tidy(conf.int = TRUE, conf.level = .99) |>
            mutate(banda = banda, forma = "log")
        )
        
      })
  })(df = _) |> 
  drop_na() |> 
  # filter(term != "(Intercept)") |> 
  ggplot(aes(x = banda, y = estimate, colour = term, fill = term)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .5) +
  geom_line(lwd = 1) +
  ggh4x::facet_grid2(cols = vars(forma), rows = vars(term), scale = "free", independent = "y") +
  scale_colour_viridis_d() +
  scale_fill_viridis_d() +
  theme_classic() +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::number) +
  labs(x = "Bandwidth do recorte do espectro de irregularidade", y = "Estimativa do parâmetro", colour = "Parâmetro", fill = "Parâmetro")
```



```{r}
split <- rsample::initial_split(result %>% 
                                  drop_na() %>% 
                                  filter(area > max(area) * .99) %>% 
                                  select(-c(densidade_residencial, populacao, area, 
                                            cota_parte_inversa, x, y)),
                                prop = 0.8)
train <- rsample::training(split)
test <- rsample::testing(split)

# rf_model <- ranger::ranger(densidade_total ~ ., 
#                            data = train, num.trees = 100000, importance = "permutation")
# rf_preds <- predict(rf_model, data = test)$predictions

rf_model_restrito <- ranger::ranger(densidade_total ~ CA + cota_parte + verticalizacao + espectro_irregularidade, 
                                    data = train, num.trees = 200000)

# rf_preds_restrito <- predict(rf_model_restrito, data = test)$predictions

lm_model_restrito <- lm(logdensidade_total ~ CA + cota_parte + verticalizacao, 
                                    data = result |> filter(abs(espectro_irregularidade - .5) < .05))

lm_model_restrito |> summary()
```

```{r}
df <- tibble()
for (cota_parte in (4:15) ^2){
  for (CA in seq(0, 8, by = 1)){
    for (verticalizacao in c(8, 12)){
      df <- df |> 
        bind_rows(tibble(cota_parte = cota_parte, CA = CA, verticalizacao = verticalizacao))
    }
  }
}

df |> 
  mutate(preds = predict(lm_model_restrito,
                           newdata = tibble(CA = CA,
                                       cota_parte = cota_parte,
                                       verticalizacao = verticalizacao)) |> as.numeric(),
         preds = cut(preds * 640000, breaks = 0:10 * 2000, dig.lab = 6),
         verticalizacao = paste(verticalizacao, "pavimentos") |> 
           factor(levels = c("8 pavimentos", "12 pavimentos"))) |> 
  ggplot(aes(x = CA, y = cota_parte, fill = preds)) +
  geom_tile() +
  facet_wrap(~verticalizacao, dir = "h") +
  scale_fill_viridis_d() +
  scale_y_sqrt(breaks = c(10, 20, 40, 80, 160, 320)) +
  theme_classic() +
  labs(fill = "População Prevista", x = "Coeficiente de Aproveitamento (CA)",
       y = "Cota Parte")

df |> 
  mutate(preds = predict(rf_model_restrito,
                           data = tibble(CA = CA,
                                       cota_parte = cota_parte,
                                       verticalizacao = verticalizacao,
                                       espectro_irregularidade = .5)) |> 
           ranger::predictions(),
         preds = cut(preds * 640000, breaks = 0:10 * 2000, dig.lab = 6),
         verticalizacao = paste(verticalizacao, "pavimentos") |> 
           factor(levels = c("8 pavimentos", "12 pavimentos"))) |> 
  ggplot(aes(x = CA, y = cota_parte, fill = preds)) +
  geom_tile() +
  facet_wrap(~verticalizacao, dir = "h") +
  scale_fill_viridis_d() +
  scale_y_sqrt(breaks = c(10, 20, 40, 80, 160, 320)) +
  theme_classic() +
  labs(fill = "População Prevista", x = "Coeficiente de Aproveitamento (CA)",
       y = "Cota Parte")

# ggsave("tex/figuras/previsoes.pdf", width = 9, height = 4.25)

```

